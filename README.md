## 记录我在用python刷leetcode中各个题的解题思路
## the answers for leetcode problem by python


### 31.NextPermutation:
这个题是要求找到给定数组排列的下一个 [字典序](https://zh.wikipedia.org/zh-hans/%E5%AD%97%E5%85%B8%E5%BA%8F)，如果把给的数组当作一个组合数，则下一个字典序
就是找到在这些数所有排列组合数中略大于这个数的组合数，如果没有，就按升序返回。从左往右看时，如果是递增或不变则这个数是当前组合数中最大的，直接转置即可。如果递增不变中断了
那中断的地方则是可增加最小的地方，然后将这个数与其右边最小大于它的数交换，然后再转置这个位置的右边，即为所得字典序。

### 33.Search in Rotated Sorted Array:
用最简单粗暴的办法，直接循环比较，下一部用二分查找来优化
二分查找法：先用二分查找找出旋转点，再用二分查找法查找两段，看目标是否在数组中。
二分查找法其实不用找到旋转点：可以直接做，每次比较中间和两端，target一定在这两个区间，如果存在的话。


### 136.Single Number:
easy难度，要求线性复杂时间，直接上dict简单粗暴。

看了solution，发现了位操作这种有趣的答案。用^可以只用O(1)的空间复杂度:
0^a=a,a^a=0,a^b^a=(a^a)^b=b


### 75.Sort Colors:
简单粗暴解法就是计数，循环一遍知道0，1，2个数即可。再循环一遍赋值。这个实名复杂度为2*O(n)

还有一种就是设定两个指针，分别指向下一个0和2应该在的地方，即乱序的最左与最右。
遇到0则交换左指针指向的数和0，然后左指针右移同时对下一个元素进行判定。遇到2则于右指针指向的数交换，右指针左移，但是继续对这个元素判定，因为换过来的数可能是0，也可能是1。遇到1不动，直到循环到达右指针指向的地方。
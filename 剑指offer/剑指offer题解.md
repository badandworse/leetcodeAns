### 31.栈的压入、弹出序列:

这题就是利用一个辅助栈，然后开始按照压入顺序压入，压入时，检测压入元素和出栈序列的第一个元素是否相等，如果相等，删除入栈和出栈序列的头元素，然后继续，如果不相等，将元素压入栈，并删除入栈序列的第一个元素。重复上述过程直到入栈序列为空。如果辅助栈和出栈均为空，则返回True,如果都不为空，辅助栈开始出栈与出栈的首元素比较，相等则比较下一元素，否则返回False。如果最后只有一个非空，则返回False。

#### 33.二叉搜索数的后序遍历序列:

后序遍历的最后一个节点是根节点，这个序列应该分为两段，一段是左子树，所有值都要小于根节点的值，一段是右子树，所有值都要大于根节点的值，不满足就不是BST，返回False。一个递归的过程。

### 35.复杂链表的复制:

首先复制所有元素并将其添加为原来元素的next节点，同时复制random指向
然后删除链表中原来的节点，将新的节点取出来，并且，链表中的random和next全部向后平移一位。


### 36.二叉搜索树与双向链表:

变换后，根节点的左指针指向左子树的最右节点，根节点的右指针指向右子树的最左，对左右子树做相同处理，即递归。


### 40.最小的k个数:

利用快排的思想，每次将小于某个值的元素丢在元素左边，将大于等于该值的元素放在该元素的右边，返回index，如果index==k-1则这个元素的右边加这个元素就是这k个数，大于则这k个元素在左边，否则在右边，重复上述过程。

### 42.连续子数组的最大和:

利用动态规划 f(i)=max(f(i-1)+i,i),返回max(f(i))即可。如果f(i-1)<0 显然抛弃f(i-1) 令f(i)=i

### 43. 1~n整数中1出现的次数:

用暴力破解肯定不行，转换思路，将这些整数转换成一个拼接字符串，然后找到这个拼接字符串中'1'的个数即可。

### 45.把数组排成最小的数：

转换为str，在根据和的大小排序，然后再拼接即可


### 51.数组中的逆序对：

利用归并排序来做是可以的，合并的时候统计前一段与后一段的大小来确定有多少逆序对。

### 52.在排序数组中查找数字：

二分查找找出首和尾，然后减并+1就是次数了

### 61.扑克牌顺子:

给定的数字排序，统计出0的个数，然后统计，如果有对子，肯定不是顺子，然后看需要多少个0能凑出一个顺子，如果需要数小于等于0的个数，那就是顺子，反之，不是。